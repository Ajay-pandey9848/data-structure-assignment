Q.2.

class Node():
    def __init__(self, data, parent_node=None, left_child=None, right_child=None):
        self.data = data
        self._parent = parent_node
        self._left_child = left_child
        self._right_child = right_child

    def __repr__(self):
        left = self._left_child if self._left_child is not None else ''
        right = self._right_child if self._right_child is not None else ''
        return f'{self.data}<{left}><{right}>#'


class Tree():
    def __init__(self):
        self._root_node = None

    def __repr__(self):
        return f'<Tree: {self._root_node}>'

    def insert(self, data):
        current_node = self._root_node
        parent_node = None
        while current_node:
            parent_node = current_node
            if data <= current_node.data:
                current_node = current_node._left_child
            else:
                current_node = current_node._right_child

        new_node = Node(data, parent_node=parent_node)
        if parent_node is None:
            if self._root_node is None:
                self._root_node = new_node
            else:
                raise(ValueError)
        elif new_node.data < parent_node.data:
            parent_node._left_child = new_node
        else:
            parent_node._right_child = new_node

    def _find(self, data):
        current = self._root_node
        while current:
            if current.data == data:
                return current
            elif current.data > data:
                current = current._left_child
            else:
                current = current._right_child
        return None

    def find_minimum(self):
        """
        Returns the node containing the minimum value of the tree.
        """
        current = self._root_node
        if current is None:
            return None

        while current._left_child is not None:
            current = current._left_child

        return current

    def find_maximum(self):
        """
        Returns the node containing the maximum value of the tree.
        """
        current = self._root_node
        if current is None:
            return None

        while current._right_child is not None:
            current = current._right_child

        return current # this is a comment

    Q.1

    class Node():
        def __init__(self, data, parent_node=None, left_child=None, right_child=None):
            self.data = data
            self._parent = parent_node
            self._left_child = left_child
            self._right_child = right_child

        def __repr__(self):
            left = self._left_child if self._left_child is not None else ''
            right = self._right_child if self._right_child is not None else ''
            return f'{self.data}<{left}><{right}>#'

    class Tree():
        def __init__(self):
            self._root_node = None

        def __repr__(self):
            return f'<Tree: {self._root_node}>'

        def insert(self, data):
            current_node = self._root_node
            parent_node = None
            while current_node:
                parent_node = current_node
                if data <= current_node.data:
                    current_node = current_node._left_child
                else:
                    current_node = current_node._right_child

            new_node = Node(data, parent_node=parent_node)
            if parent_node is None:
                if self._root_node is None:
                    self._root_node = new_node
                else:
                    raise (ValueError)
            elif new_node.data < parent_node.data:
                parent_node._left_child = new_node
            else:
                parent_node._right_child = new_node

        def _find(self, data):
            current_node = self._root_node

            while current_node is not None:
                if data == current_node.data:
                    return current_node
                elif data < current_node.data:
                    current_node = current_node._left_child
                else:
                    current_node = current_node._right_child

            return None # this is a comment

        Q.3 ans:

        def _detach_node(self, node):
            """
            Detach a node from the tree. Node to be detached has one child at most.
            An error will be raised otherwise.
            """

            if node is None:
                return

            # Case 1: Node has two children â†’ not allowed
            if node._left_child is not None and node._right_child is not None:
                raise ValueError("Cannot detach a node with two children")

            # Determine the child (if any)
            child = node._left_child if node._left_child is not None else node._right_child

            # Case 2: Node is the root
            if node._parent is None:
                self._root_node = child
                if child is not None:
                    child._parent = None
                return

            # Case 3: Node is a left child of its parent
            if node._parent._left_child is node:
                node._parent._left_child = child
            else:
                # Case 4: Node is a right child of its parent
                node._parent._right_child = child

            # Update child's parent pointer
            if child is not None:
                child._parent = node._parent



